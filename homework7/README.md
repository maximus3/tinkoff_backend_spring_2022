# Async Chat

## Description

Async CLI chat.

Implemented with FastAPI and Redis Pub-Sub.

## Commands

### Docker clean, build, up, clean
    make docker

### Up docker container:
    make docker-up

### Down docker container:
    make docker-down

### Create venv (if no docker):
    make venv

### Run app:
    make up

### Run tests:
    make test

### Run linters:
    make lint

### Run formatters:
    make format

### Run format and lint code then run tests:
    make check

## Task Description:
Ваша задача реализовать сервис чата для переписки между пользователями.

### Бизнес-логика
В основном варианте должна быть реализована только одна общая комната для переписки, в которой переписываются все пользователи. 

При подключении клиент может запросить последние сообщения в чате через rest эндпоинт, затем подключается к каналу обмена сообщениями (websocket), в который можно писать сообщения и принимать сообщения от других пользователей в реальном времени. 

### Технические особенности  

* Сервис должен быть асинхронным (написанным с помощью asyncio) 
* Решение нужно построить на базе fastapi и websocket протокола 
* При подключении к каналу сокета по redis pub / sub необходимо получать / писать сообщения. Асинхронный клиент можно взять тут (aioredis). 
* Хранить последние 50 сообщений переписки в redis. Можно использовать список в redis и команду trim для создания буфера заданной длины.

### Обязательные требования 

* Покрыть сервис тестами (make test) 
* Покрыть код аннотациями типов. (make lint запускает mypy для проверки) 
* Код должен проходить проверки линтеров и быть автоматически отформатирован (make format lint) 
* Сервис запускается по команде make up. 
* Все зависимости фиксируются через poetry. 
* Сервис запускается в докер контейнере. 
* Реализовать консольный клиент для чата.

### Усложненный вариант
Реализовать возможность разговаривать 1 на 1. При этом каждый клиент должен иметь возможность одновременно общаться с произвольным количеством людей. Для этого нужно хранить список всех активных коннектов. Учесть, что нужно поддерживать консистентность: если клиентский веб-сокет закрылся, пользователь должен быть удалён из списка активных. Если при удалении произошла ошибка, пользователь должен быть удалён по TTL. При отправке сообщений пользователь всегда должен указывать конкретного получателя.